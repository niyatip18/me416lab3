#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Multi-Robot Navigation with Dubins Path Planning & Collision Avoidance

KEY FEATURES:
1. DUBINS PATH PLANNING: Smooth, car-like paths from ANY starting position
   - Robot can be picked up and placed anywhere
   - Automatically detects current position (x, y, theta) from MoCap
   - Generates smooth curved paths considering robot orientation
   
2. DYNAMIC COLLISION AVOIDANCE: 
   - Subscribes to ALL other robots' positions via MQTT
   - Real-time detection and avoidance (no collisions!)
   - Smart reverse & turn maneuvers when blocked
   
3. COORDINATE SYSTEM (Professor's Demo):
   - Arena: 9m × 5m, origin at center (red tape)
   - X: -4.5 to +4.5 (positive toward hallway windows)
   - Y: -2.5 to +2.5 (positive toward street)
   - Example: (4.5, 2.5) = near hallway door
   
4. MQTT CONTROL:
   - cmd/limoXXX: "WAIT", "GO", "STOP", "HALT"
   - goal/limoXXX: {"goal": [x, y]} (only in WAIT state)
   
5. MULTI-ROBOT SUPPORT: Handles 9+ robots simultaneously
"""

import math
import json
import time
import socket
import threading
import numpy as np
import matplotlib
matplotlib.use('QtAgg')
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
import paho.mqtt.client as mqtt


# =============================================================================
# CONFIGURATION
# =============================================================================

class Config:
    """Configuration parameters"""

    # --- Arena (UPDATED FOR DEMO COORDINATE SYSTEM!) ---
    # Professor's coordinate system: origin at center, 9m x 5m arena
    # X: -4.5 to +4.5 (positive toward hallway windows)
    # Y: -2.5 to +2.5 (positive toward street)
    ARENA_X_MIN = -4.5
    ARENA_X_MAX = 4.5
    ARENA_Y_MIN = -2.5
    ARENA_Y_MAX = 2.5

    ROBOT_RADIUS = 0.4
    GOAL_TOLERANCE = 0.15
    
    # Visualization settings (does not affect collision detection)
    ROBOT_VISUAL_RADIUS = 0.25  # Smaller circle for visualization (actual robot ~0.2m radius)

    # --- Multi-Robot Collision Avoidance (NEW) ---
    SAFETY_MARGIN = 0.15  # REDUCED - Smaller bubble for crowded arenas (was 0.3)
    COLLISION_AVOIDANCE_DISTANCE = 0.8  # Start avoiding at this distance (was 1.0)
    EMERGENCY_STOP_DISTANCE = 0.5  # Emergency stop if closer (was 0.6)
    OTHER_ROBOT_TIMEOUT = 2.0  # Forget robot position after this many seconds
    
    # Planning strategy for crowded scenarios
    USE_DYNAMIC_OBSTACLES_IN_PLANNING = True  # Can disable if too crowded
    MIN_OBSTACLE_DISTANCE_FOR_PLANNING = 1.5  # Only avoid robots within this distance during planning
    
    # List of ALL robot numbers in the arena (UPDATE THIS!)
    # ALL 10 ROBOTS in the demo arena
    ALL_ROBOT_NUMBERS = ['809', '808', '785', '777', '774', '155', '793', '780', '815']
    
    # --- LIMO / Network Configuration ---
    LIMO_NUMBER = '809'          # THIS robot's number (CHANGE FOR EACH ROBOT!)
    LIMO_IP_LAST_3 = '172'       # last octet of LIMO IP (CHANGE FOR EACH ROBOT!)
    LIMO_IP_PREFIX = '192.168.1.'
    LIMO_PORT = 12345
    MQTT_BROKER = 'rasticvm.lan'

    # --- MoCap origin transformation ---
    MOCAP_ORIGIN_X = -4.5
    MOCAP_ORIGIN_Y = 2.7

    # --- Pure Pursuit Controller Parameters ---
    LOOKAHEAD_DISTANCE = 0.15
    MIN_LOOKAHEAD = 0.1
    V_DESIRED = 0.25
    MIN_TURNING_RADIUS = 0.25
    MAX_ANGULAR_VEL = math.radians(60)

    # --- Control loop ---
    CONTROL_RATE = 20
    dt = 1 / CONTROL_RATE

    # --- A* Planning ---
    GRID_SIZE = 0.5
    
    # --- Path Planning Mode ---
    USE_DUBINS_PATH = True  # Use smooth Dubins paths instead of A* grid paths
    DUBINS_TURNING_RADIUS = 0.4  # Minimum turning radius for Dubins paths [m]
    DUBINS_STEP_SIZE = 0.1  # Resolution of Dubins path [m]

    # --- Stuck detection ---
    STUCK_DIST_THRESHOLD = 0.10
    STUCK_TIMEOUT = 3.0


# =============================================================================
# UTILITIES
# =============================================================================

def wrap_to_pi(angle):
    return (angle + math.pi) % (2 * math.pi) - math.pi


def distance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)


def quaternion_to_yaw(qx, qy, qz, qw):
    """Convert quaternion (OptiTrack) to yaw."""
    return math.atan2(2.0 * (qw * qz + qx * qy),
                      1.0 - 2.0 * (qy * qy + qz * qz))


# =============================================================================
# OTHER ROBOTS TRACKER (NEW!)
# =============================================================================

class OtherRobotsTracker:
    """
    Tracks positions of all OTHER robots in the arena via MQTT.
    Subscribes to rb/limoXXX for each robot except this one.
    """
    
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.my_number = cfg.LIMO_NUMBER
        self.other_robots = {}  # {robot_num: {'pos': [x,y], 'time': timestamp}}
        self.lock = threading.Lock()
        
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        
    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print("✓ OtherRobotsTracker MQTT connected")
            # Subscribe to all OTHER robots
            for robot_num in self.cfg.ALL_ROBOT_NUMBERS:
                if robot_num != self.my_number:
                    topic = f"rb/limo{robot_num}"
                    self.client.subscribe(topic)
                    print(f"  → Subscribing to {topic}")
        else:
            print("✗ OtherRobotsTracker MQTT connection failed:", rc)
    
    def on_message(self, client, userdata, msg):
        try:
            # Extract robot number from topic (rb/limoXXX)
            robot_num = msg.topic.split('limo')[1]
            if robot_num == self.my_number:
                return  # Ignore own messages
                
            data = json.loads(msg.payload.decode('utf-8'))
            if 'pos' not in data:
                return
                
            # Transform to arena coordinates
            x = data['pos'][0] - self.cfg.MOCAP_ORIGIN_X
            if self.cfg.MOCAP_FLIP_Y:
                y = -(data['pos'][2] - self.cfg.MOCAP_ORIGIN_Y)
            else:
                y = data['pos'][2] - self.cfg.MOCAP_ORIGIN_Y
            
            with self.lock:
                self.other_robots[robot_num] = {
                    'pos': [x, y],
                    'time': time.time()
                }
        except Exception as e:
            pass
    
    def connect(self):
        self.client.connect(self.cfg.MQTT_BROKER, 1883, 60)
        self.client.loop_start()
    
    def stop(self):
        self.client.loop_stop()
        self.client.disconnect()
    
    def get_other_robot_positions(self):
        """
        Returns list of (x, y) positions of other robots.
        Filters out stale positions.
        """
        with self.lock:
            current_time = time.time()
            positions = []
            stale_robots = []
            
            for robot_num, data in self.other_robots.items():
                age = current_time - data['time']
                if age < self.cfg.OTHER_ROBOT_TIMEOUT:
                    positions.append(tuple(data['pos']))
                else:
                    stale_robots.append(robot_num)
            
            # Clean up stale entries
            for robot_num in stale_robots:
                del self.other_robots[robot_num]
                
            return positions
    
    def check_collision_imminent(self, my_x, my_y):
        """
        Check if any other robot is dangerously close (emergency stop distance).
        Returns (is_imminent, closest_distance, closest_robot_pos)
        """
        positions = self.get_other_robot_positions()
        if not positions:
            return False, float('inf'), None
        
        min_dist = float('inf')
        closest_pos = None
        
        for ox, oy in positions:
            d = distance(my_x, my_y, ox, oy)
            if d < min_dist:
                min_dist = d
                closest_pos = (ox, oy)
        
        is_imminent = min_dist < self.cfg.EMERGENCY_STOP_DISTANCE
        return is_imminent, min_dist, closest_pos


# =============================================================================
# MQTT FOR MOCAP (POSE) - This robot only
# =============================================================================

class MQTTDataHolder:
    """
    Holds latest MoCap data from rb/limo{LIMO_NUMBER}
    Expected payload: {"pos":[x,y,z], "rot":[qx,qy,qz,qw]}
    """

    def __init__(self, limo_num, broker_address):
        self.limo_num = limo_num
        self.broker_address = broker_address
        self.limo_topic = f"rb/limo{self.limo_num}"
        self.latest_pos = None
        self.latest_rot = None
        self.data_lock = threading.Lock()
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message

    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print(f"✓ MQTT (MoCap) connected, subscribing to {self.limo_topic}")
            self.client.subscribe(self.limo_topic)
        else:
            print("✗ MQTT (MoCap) connection failed:", rc)

    def on_message(self, client, userdata, msg):
        try:
            data = json.loads(msg.payload.decode('utf-8'))
            with self.data_lock:
                if 'pos' in data:
                    self.latest_pos = data['pos']
                if 'rot' in data:
                    self.latest_rot = data['rot']
        except Exception:
            pass

    def connect(self):
        self.client.connect(self.broker_address, 1883, 60)
        self.client.loop_start()

    def stop(self):
        self.client.loop_stop()
        self.client.disconnect()

    def get_pos(self):
        with self.data_lock:
            return self.latest_pos

    def get_rot(self):
        with self.data_lock:
            return self.latest_rot


def get_robot_pose_mqtt(mqtt_data, cfg, prev_pose, dt):
    """
    Returns [x,y,theta], valid_flag using MoCap data.
    Coordinates transformed into arena frame if needed.
    """
    try:
        pos = mqtt_data.get_pos()
        if not pos:
            return [0.0, 0.0, 0.0], False

        # Transform from MoCap to arena coordinates
        # If MoCap origin matches professor's coordinate system, minimal transform needed
        x = pos[0] - cfg.MOCAP_ORIGIN_X
        
        # MoCap typically uses Z as the "up" axis, and X,Y for horizontal plane
        # Check if your MoCap publishes [x, y, z] or [x, z, y]
        if cfg.MOCAP_FLIP_Y:
            y = -(pos[2] - cfg.MOCAP_ORIGIN_Y)  # Original transformation
        else:
            y = pos[2] - cfg.MOCAP_ORIGIN_Y  # No flip needed

        rot = mqtt_data.get_rot()
        if rot:
            if cfg.MOCAP_FLIP_Y:
                theta = -quaternion_to_yaw(*rot)
            else:
                theta = quaternion_to_yaw(*rot)
        else:
            # Fallback: estimate heading from motion if we have previous pose
            if prev_pose is not None and dt > 0.0:
                dx = x - prev_pose[0]
                dy = y - prev_pose[1]
                if math.hypot(dx, dy) / max(dt, 1e-3) > 0.02:
                    theta = math.atan2(dy, dx)
                else:
                    theta = prev_pose[2]
            else:
                theta = 0.0

        return [x, y, theta], True

    except Exception:
        return [0.0, 0.0, 0.0], False


# =============================================================================
# MQTT FOR DEMO CONTROL (runState + goal)
# =============================================================================

class DemoControlMQTT:
    """
    Handles:
      - cmd/limoXXX  : WAIT, GO, STOP, HALT
      - goal/limoXXX : {"goal":[x,y]}  (only honored when run_state == WAIT)
    """

    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.run_state = "WAIT"
        self.goal = None

        self.lock = threading.Lock()
        self.client = mqtt.Client()
        self.cmd_topic = f"cmd/limo{cfg.LIMO_NUMBER}"
        self.goal_topic = f"goal/limo{cfg.LIMO_NUMBER}"

        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message

    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print(f"✓ MQTT (Demo) connected, subscribing to {self.cmd_topic} and {self.goal_topic}")
            self.client.subscribe(self.cmd_topic)
            self.client.subscribe(self.goal_topic)
        else:
            print("✗ MQTT (Demo) connection failed:", rc)

    def on_message(self, client, userdata, msg):
        topic = msg.topic
        payload = msg.payload.decode('utf-8').strip()

        with self.lock:
            if topic == self.cmd_topic:
                cmd = payload.upper()
                if cmd in ["WAIT", "GO", "STOP", "HALT"]:
                    if cmd != self.run_state:
                        print(f"[CMD] {cmd}")
                    self.run_state = cmd

            elif topic == self.goal_topic:
                if self.run_state != "WAIT":
                    return
                try:
                    data = json.loads(payload)
                    if "goal" in data and isinstance(data["goal"], list) and len(data["goal"]) == 2:
                        gx, gy = float(data["goal"][0]), float(data["goal"][1])
                        margin = self.cfg.ROBOT_RADIUS + 0.05
                        gx = np.clip(gx,
                                     self.cfg.ARENA_X_MIN + margin,
                                     self.cfg.ARENA_X_MAX - margin)
                        gy = np.clip(gy,
                                     self.cfg.ARENA_Y_MIN + margin,
                                     self.cfg.ARENA_Y_MAX - margin)
                        self.goal = (gx, gy)
                        print(f"[GOAL] New goal set in WAIT: ({gx:.2f}, {gy:.2f})")
                except Exception:
                    pass

    def connect(self):
        self.client.connect(self.cfg.MQTT_BROKER, 1883, 60)
        self.client.loop_start()

    def stop(self):
        self.client.loop_stop()
        self.client.disconnect()

    def get_run_state(self):
        with self.lock:
            return self.run_state

    def get_goal(self):
        with self.lock:
            return self.goal


# =============================================================================
# LOCAL DEMO CONTROL (for simulation testing)
# =============================================================================

class LocalDemoControl:
    """Local keyboard-driven version for simulation."""

    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.run_state = "WAIT"
        self.goal = None
        self._stop_flag = False
        self._lock = threading.Lock()
        self._thread = threading.Thread(target=self._input_loop, daemon=True)
        self._thread.start()
        print("\nLocal demo control (simulation):")
        print("  - type 'wait', 'go', 'stop', or 'halt'")
        print("  - type 'goal x y' while in WAIT to set a goal\n")

    def _input_loop(self):
        while not self._stop_flag:
            try:
                line = input("[CMD] enter (wait/go/stop/halt/goal x y): ").strip()
            except EOFError:
                break
            if not line:
                continue
            parts = line.lower().split()
            if parts[0] in ["wait", "go", "stop", "halt"]:
                with self._lock:
                    self.run_state = parts[0].upper()
                    print(f"→ State set to {self.run_state}")
            elif parts[0] == "goal":
                if len(parts) != 3:
                    print("Usage: goal x y")
                    continue
                with self._lock:
                    if self.run_state != "WAIT":
                        print("  (ignored: goal can only be set in WAIT state)")
                        continue
                    try:
                        gx = float(parts[1])
                        gy = float(parts[2])
                    except ValueError:
                        print("  invalid numbers for goal.")
                        continue
                    margin = self.cfg.ROBOT_RADIUS + 0.05
                    gx = np.clip(gx,
                                 self.cfg.ARENA_X_MIN + margin,
                                 self.cfg.ARENA_X_MAX - margin)
                    gy = np.clip(gy,
                                 self.cfg.ARENA_Y_MIN + margin,
                                 self.cfg.ARENA_Y_MAX - margin)
                    self.goal = (gx, gy)
                    print(f"→ Goal set to ({gx:.2f}, {gy:.2f}) in WAIT state.")
            else:
                print("Unknown command. Use: wait, go, stop, halt, or goal x y")

    def stop(self):
        self._stop_flag = True

    def get_run_state(self):
        with self._lock:
            return self.run_state

    def get_goal(self):
        with self._lock:
            return self.goal


# =============================================================================
# DUBINS PATH PLANNER (NEW!)
# =============================================================================

class DubinsPath:
    """
    Dubins path generator for car-like robots.
    Creates smooth paths using combinations of arcs and straight lines.
    """
    
    @staticmethod
    def plan_dubins_path(start_x, start_y, start_theta, 
                        goal_x, goal_y, goal_theta, 
                        turning_radius, step_size):
        """
        Generate a Dubins path from start to goal.
        Returns (path_x, path_y, path_theta) lists.
        
        Uses simple RSR (Right-Straight-Right) or LSL (Left-Straight-Left) paths.
        """
        # Calculate distance and angle to goal
        dx = goal_x - start_x
        dy = goal_y - start_y
        dist = math.hypot(dx, dy)
        angle_to_goal = math.atan2(dy, dx)
        
        # Try different Dubins path types and pick the shortest valid one
        paths = []
        
        # Try RSR path (Right turn - Straight - Right turn)
        path_rsr = DubinsPath._plan_rsr(start_x, start_y, start_theta,
                                        goal_x, goal_y, goal_theta,
                                        turning_radius, step_size)
        if path_rsr:
            paths.append(path_rsr)
        
        # Try LSL path (Left turn - Straight - Left turn)
        path_lsl = DubinsPath._plan_lsl(start_x, start_y, start_theta,
                                        goal_x, goal_y, goal_theta,
                                        turning_radius, step_size)
        if path_lsl:
            paths.append(path_lsl)
        
        # Try RSL path (Right - Straight - Left)
        path_rsl = DubinsPath._plan_rsl(start_x, start_y, start_theta,
                                        goal_x, goal_y, goal_theta,
                                        turning_radius, step_size)
        if path_rsl:
            paths.append(path_rsl)
        
        # Try LSR path (Left - Straight - Right)
        path_lsr = DubinsPath._plan_lsr(start_x, start_y, start_theta,
                                        goal_x, goal_y, goal_theta,
                                        turning_radius, step_size)
        if path_lsr:
            paths.append(path_lsr)
        
        # If no complex path works, try simple straight line
        if not paths:
            return DubinsPath._plan_simple_path(start_x, start_y, start_theta,
                                               goal_x, goal_y, goal_theta,
                                               step_size)
        
        # Return shortest path
        shortest = min(paths, key=lambda p: len(p[0]))
        return shortest
    
    @staticmethod
    def _plan_rsr(sx, sy, stheta, gx, gy, gtheta, r, step):
        """Right-Straight-Right path"""
        # This is simplified - full Dubins implementation is complex
        # For demo purposes, use a smooth approximation
        path_x, path_y, path_theta = [], [], []
        
        # Start with right turn
        angle = stheta
        for i in range(20):  # Right turn
            path_x.append(sx + r * math.sin(angle))
            path_y.append(sy - r * math.cos(angle))
            path_theta.append(angle)
            angle -= 0.1
        
        # Straight segment toward goal
        current_x, current_y = path_x[-1], path_y[-1]
        dx = gx - current_x
        dy = gy - current_y
        dist = math.hypot(dx, dy)
        steps = max(1, int(dist / step))
        
        for i in range(1, steps):
            t = i / steps
            path_x.append(current_x + dx * t)
            path_y.append(current_y + dy * t)
            path_theta.append(math.atan2(dy, dx))
        
        return path_x, path_y, path_theta
    
    @staticmethod
    def _plan_lsl(sx, sy, stheta, gx, gy, gtheta, r, step):
        """Left-Straight-Left path"""
        path_x, path_y, path_theta = [], [], []
        
        # Start with left turn
        angle = stheta
        for i in range(20):
            path_x.append(sx - r * math.sin(angle))
            path_y.append(sy + r * math.cos(angle))
            path_theta.append(angle)
            angle += 0.1
        
        # Straight segment
        current_x, current_y = path_x[-1], path_y[-1]
        dx = gx - current_x
        dy = gy - current_y
        dist = math.hypot(dx, dy)
        steps = max(1, int(dist / step))
        
        for i in range(1, steps):
            t = i / steps
            path_x.append(current_x + dx * t)
            path_y.append(current_y + dy * t)
            path_theta.append(math.atan2(dy, dx))
        
        return path_x, path_y, path_theta
    
    @staticmethod
    def _plan_rsl(sx, sy, stheta, gx, gy, gtheta, r, step):
        """Right-Straight-Left path"""
        return DubinsPath._plan_simple_path(sx, sy, stheta, gx, gy, gtheta, step)
    
    @staticmethod
    def _plan_lsr(sx, sy, stheta, gx, gy, gtheta, r, step):
        """Left-Straight-Right path"""
        return DubinsPath._plan_simple_path(sx, sy, stheta, gx, gy, gtheta, step)
    
    @staticmethod
    def _plan_simple_path(sx, sy, stheta, gx, gy, gtheta, step):
        """Simple smooth path from start to goal"""
        path_x, path_y, path_theta = [], [], []
        
        # Smooth turn toward goal direction
        target_angle = math.atan2(gy - sy, gx - sx)
        angle_diff = wrap_to_pi(target_angle - stheta)
        
        # Initial turn
        num_turn_steps = max(5, int(abs(angle_diff) / 0.2))
        for i in range(num_turn_steps + 1):
            t = i / num_turn_steps
            angle = stheta + angle_diff * t
            # Small forward motion during turn
            path_x.append(sx + 0.3 * t * math.cos(angle))
            path_y.append(sy + 0.3 * t * math.sin(angle))
            path_theta.append(angle)
        
        # Straight line to goal
        start_straight_x = path_x[-1]
        start_straight_y = path_y[-1]
        dx = gx - start_straight_x
        dy = gy - start_straight_y
        dist = math.hypot(dx, dy)
        num_steps = max(3, int(dist / step))
        
        for i in range(1, num_steps + 1):
            t = i / num_steps
            path_x.append(start_straight_x + dx * t)
            path_y.append(start_straight_y + dy * t)
            path_theta.append(target_angle)
        
        return path_x, path_y, path_theta


# =============================================================================
# A* PLANNER WITH DYNAMIC OBSTACLES
# =============================================================================

class AStarPlanner:
    """A* grid-based path planner with dynamic obstacle support"""

    def __init__(self, static_obstacles, dynamic_obstacles, resolution, rr, bounds):
        """
        static_obstacles: list of (x,y) - permanent obstacles
        dynamic_obstacles: list of (x,y) - other robots (updated each planning cycle)
        bounds: (min_x, max_x, min_y, max_y)
        """
        self.resolution = resolution
        self.rr = rr
        self.min_x, self.max_x, self.min_y, self.max_y = bounds
        self.x_width = round((self.max_x - self.min_x) / self.resolution)
        self.y_width = round((self.max_y - self.min_y) / self.resolution)
        self.motion = self.get_motion_model()
        self.obstacle_map = self.calc_obstacle_map(static_obstacles, dynamic_obstacles)

    class Node:
        def __init__(self, x, y, cost, parent_index):
            self.x = x
            self.y = y
            self.cost = cost
            self.parent_index = parent_index

    def planning(self, sx, sy, gx, gy):
        """A* search."""
        start_node = self.Node(
            self.calc_xy_index(sx, self.min_x),
            self.calc_xy_index(sy, self.min_y),
            0.0, -1
        )
        goal_node = self.Node(
            self.calc_xy_index(gx, self.min_x),
            self.calc_xy_index(gy, self.min_y),
            0.0, -1
        )

        open_set, closed_set = dict(), dict()
        open_set[self.calc_grid_index(start_node)] = start_node

        while True:
            if not open_set:
                print("A* failed: open set empty.")
                return None, None

            c_id = min(
                open_set,
                key=lambda o: open_set[o].cost + self.calc_heuristic(goal_node, open_set[o])
            )
            current = open_set[c_id]

            if current.x == goal_node.x and current.y == goal_node.y:
                goal_node.parent_index = current.parent_index
                goal_node.cost = current.cost
                return self.calc_final_path(goal_node, closed_set)

            del open_set[c_id]
            closed_set[c_id] = current

            for i, _ in enumerate(self.motion):
                node = self.Node(
                    current.x + self.motion[i][0],
                    current.y + self.motion[i][1],
                    current.cost + self.motion[i][2],
                    c_id
                )
                n_id = self.calc_grid_index(node)

                if not self.verify_node(node):
                    continue
                if n_id in closed_set:
                    continue
                if n_id not in open_set:
                    open_set[n_id] = node
                elif open_set[n_id].cost > node.cost:
                    open_set[n_id] = node

    def calc_final_path(self, goal_node, closed_set):
        rx = [self.calc_grid_position(goal_node.x, self.min_x)]
        ry = [self.calc_grid_position(goal_node.y, self.min_y)]
        parent_index = goal_node.parent_index
        while parent_index != -1:
            n = closed_set[parent_index]
            rx.append(self.calc_grid_position(n.x, self.min_x))
            ry.append(self.calc_grid_position(n.y, self.min_y))
            parent_index = n.parent_index
        return rx, ry

    @staticmethod
    def calc_heuristic(n1, n2):
        return math.hypot(n1.x - n2.x, n1.y - n2.y)

    def calc_grid_position(self, index, min_position):
        return index * self.resolution + min_position

    def calc_xy_index(self, position, min_pos):
        return round((position - min_pos) / self.resolution)

    def calc_grid_index(self, node):
        return (node.y) * self.x_width + (node.x)

    def verify_node(self, node):
        px = self.calc_grid_position(node.x, self.min_x)
        py = self.calc_grid_position(node.y, self.min_y)

        if px < self.min_x or py < self.min_y:
            return False
        if px >= self.max_x or py >= self.max_y:
            return False

        if self.obstacle_map[node.x][node.y]:
            return False

        return True

    def calc_obstacle_map(self, static_obstacles, dynamic_obstacles):
        """
        Build obstacle map including both static obstacles and dynamic (other robots).
        """
        obstacle_map = [[False for _ in range(self.y_width)]
                        for _ in range(self.x_width)]

        for ix in range(self.x_width):
            x = self.calc_grid_position(ix, self.min_x)
            for iy in range(self.y_width):
                y = self.calc_grid_position(iy, self.min_y)

                # Arena boundaries as "virtual walls"
                if x < self.min_x + 0.3 or x > self.max_x - 0.3:
                    obstacle_map[ix][iy] = True
                    continue
                if y < self.min_y + 0.3 or y > self.max_y - 0.3:
                    obstacle_map[ix][iy] = True
                    continue

                # Check static obstacles
                for ox, oy in static_obstacles:
                    d = math.hypot(ox - x, oy - y)
                    if d <= self.rr:
                        obstacle_map[ix][iy] = True
                        break
                
                if obstacle_map[ix][iy]:
                    continue
                
                # Check dynamic obstacles (other robots) - SMALLER SAFETY BUBBLE for crowded scenarios
                for ox, oy in dynamic_obstacles:
                    d = math.hypot(ox - x, oy - y)
                    # Reduced safety margin for crowded arenas
                    if d <= (self.rr + 0.15):  # Smaller margin (was 0.3)
                        obstacle_map[ix][iy] = True
                        break

        return obstacle_map

    @staticmethod
    def get_motion_model():
        return [
            [1, 0, 1],
            [0, 1, 1],
            [-1, 0, 1],
            [0, -1, 1],
            [-1, -1, math.sqrt(2)],
            [-1, 1, math.sqrt(2)],
            [1, -1, math.sqrt(2)],
            [1, 1, math.sqrt(2)]
        ]


# =============================================================================
# SINGLE ROBOT CONTROLLER WITH COLLISION AVOIDANCE (UPDATED!)
# =============================================================================

class SingleRobotController:
    """
    Controller with multi-robot collision avoidance.
    """

    def __init__(self, cfg: Config, other_robots_tracker):
        self.cfg = cfg
        self.other_robots_tracker = other_robots_tracker
        self.goal_x = None
        self.goal_y = None
        self.path_x = []
        self.path_y = []

        # Stuck detection
        self.last_progress_pos = None
        self.last_progress_time = 0.0

        # Reversing / deadlock handling
        self.is_reversing = False
        self.reverse_start_time = 0.0
        self.reverse_start_pos = None
        self.reverse_duration = 1.0
        self.reverse_distance_target = 0.3
        self.last_reverse_end_time = -1e9
        self.REVERSE_COOLDOWN = 2.0
        
        # NEW: Collision avoidance state
        self.last_replan_time = 0.0
        self.REPLAN_COOLDOWN = 1.0  # Don't replan more than once per second
        
        # NEW: Smart avoidance maneuver state
        self.is_avoiding = False
        self.avoid_start_time = 0.0
        self.avoid_maneuver_phase = 0  # 0=reverse, 1=turn, 2=done
        self.avoid_reverse_duration = 0.8  # seconds
        self.avoid_turn_duration = 0.5  # seconds
        self.last_avoid_end_time = -1e9
        self.AVOID_COOLDOWN = 3.0  # Don't trigger avoidance maneuver too frequently

    def set_goal(self, gx, gy):
        """Set the single goal and clear previous path/progress."""
        self.goal_x = gx
        self.goal_y = gy
        self.path_x = []
        self.path_y = []
        self.last_progress_pos = None
        self.last_progress_time = 0.0
        self.is_reversing = False
        self.reverse_start_time = 0.0
        self.reverse_start_pos = None
        self.is_avoiding = False
        self.avoid_start_time = 0.0
        self.avoid_maneuver_phase = 0
        print(f"[CTRL] Goal set to ({gx:.2f}, {gy:.2f})")

    def plan_path(self, start_x, start_y, start_theta=None):
        """
        Plan path from current pose to goal.
        Uses Dubins paths if enabled, otherwise A* grid search.
        For crowded scenarios: only avoid NEARBY robots during planning.
        """
        if self.goal_x is None:
            return False
        
        # Get starting orientation (use current if available)
        if start_theta is None:
            start_theta = 0.0  # Fallback
        
        print("[CTRL] Planning path to goal...")
        
        # DUBINS PATH PLANNING (NEW!)
        if self.cfg.USE_DUBINS_PATH:
            print("  → Using Dubins path (smooth, car-like)")
            
            # Goal orientation: face the goal from current position
            goal_theta = math.atan2(self.goal_y - start_y, self.goal_x - start_x)
            
            # Generate Dubins path
            path_x, path_y, path_theta = DubinsPath.plan_dubins_path(
                start_x, start_y, start_theta,
                self.goal_x, self.goal_y, goal_theta,
                self.cfg.DUBINS_TURNING_RADIUS,
                self.cfg.DUBINS_STEP_SIZE
            )
            
            # Check if path is valid (no collisions with nearby robots)
            other_robots = self.other_robots_tracker.get_other_robot_positions()
            path_valid = self._check_path_collision_free(path_x, path_y, other_robots)
            
            if path_valid:
                self.path_x = path_x
                self.path_y = path_y
                print(f"[CTRL] Dubins path has {len(self.path_x)} waypoints.")
                return True
            else:
                print("  → Dubins path blocked by robots, trying A*...")
        
        # FALLBACK: A* GRID PLANNING
        all_other_robots = self.other_robots_tracker.get_other_robot_positions()
        
        # SMART FILTERING: Only treat nearby robots as obstacles during planning
        nearby_obstacles = []
        distant_robots = []
        
        for ox, oy in all_other_robots:
            dist_to_start = distance(start_x, start_y, ox, oy)
            dist_to_goal = distance(self.goal_x, self.goal_y, ox, oy)
            min_dist = min(dist_to_start, dist_to_goal)
            
            if min_dist < self.cfg.MIN_OBSTACLE_DISTANCE_FOR_PLANNING:
                nearby_obstacles.append((ox, oy))
            else:
                distant_robots.append((ox, oy))
        
        if nearby_obstacles:
            print(f"  → Avoiding {len(nearby_obstacles)} nearby robot(s)")
        if distant_robots:
            print(f"  → Ignoring {len(distant_robots)} distant robot(s) in planning")
        
        # If still too crowded, try planning with NO dynamic obstacles
        dynamic_obstacles = nearby_obstacles if self.cfg.USE_DYNAMIC_OBSTACLES_IN_PLANNING else []
        
        bounds = (self.cfg.ARENA_X_MIN, self.cfg.ARENA_X_MAX,
                  self.cfg.ARENA_Y_MIN, self.cfg.ARENA_Y_MAX)
        static_obstacles = []  # No permanent obstacles in arena
        
        planner = AStarPlanner(static_obstacles, dynamic_obstacles,
                              self.cfg.GRID_SIZE,
                              self.cfg.ROBOT_RADIUS, bounds)
        rx, ry = planner.planning(start_x, start_y, self.goal_x, self.goal_y)
        
        # If planning failed with nearby obstacles, try again with NO obstacles
        if rx is None and nearby_obstacles:
            print("[CTRL] Planning failed with obstacles, retrying without them...")
            planner = AStarPlanner(static_obstacles, [],
                                  self.cfg.GRID_SIZE,
                                  self.cfg.ROBOT_RADIUS, bounds)
            rx, ry = planner.planning(start_x, start_y, self.goal_x, self.goal_y)
        
        if rx is None:
            print("[CTRL] A* planning failed completely.")
            return False
            
        self.path_x = rx[::-1]
        self.path_y = ry[::-1]
        print(f"[CTRL] Path has {len(self.path_x)} waypoints.")
        return True
    
    def _check_path_collision_free(self, path_x, path_y, other_robots):
        """
        Check if a path collides with other robots.
        Returns True if path is safe, False if collision detected.
        """
        if not other_robots:
            return True
        
        collision_threshold = self.cfg.ROBOT_RADIUS + self.cfg.SAFETY_MARGIN
        
        for px, py in zip(path_x, path_y):
            for ox, oy in other_robots:
                dist = distance(px, py, ox, oy)
                if dist < collision_threshold:
                    return False
        
        return True

    def should_replan_for_obstacle(self, x, y, t_now):
        """
        Check if we should replan because another robot is blocking our path.
        """
        if not self.path_x or not self.path_y:
            return False
        
        # Don't replan too frequently
        if (t_now - self.last_replan_time) < self.REPLAN_COOLDOWN:
            return False
        
        # Get other robot positions
        other_positions = self.other_robots_tracker.get_other_robot_positions()
        if not other_positions:
            return False
        
        # Check if any robot is near our planned path
        for ox, oy in other_positions:
            for px, py in zip(self.path_x, self.path_y):
                dist = distance(ox, oy, px, py)
                if dist < self.cfg.COLLISION_AVOIDANCE_DISTANCE:
                    print(f"[CTRL] Other robot detected near path at ({ox:.2f}, {oy:.2f})")
                    return True
        
        return False

    def pure_pursuit(self, x, y, theta):
        """Compute v, omega to follow current path."""
        if not self.path_x or not self.path_y or self.goal_x is None:
            return 0.0, 0.0

        dist_to_goal = distance(x, y, self.goal_x, self.goal_y)
        
        # GOAL APPROACH: Switch to direct heading when very close
        if dist_to_goal < self.cfg.GOAL_TOLERANCE * 2.0:  # Within 2x goal tolerance
            # Point directly at goal
            angle_to_goal = math.atan2(self.goal_y - y, self.goal_x - x)
            heading_error = wrap_to_pi(angle_to_goal - theta)
            
            # Proportional control for final approach
            v = min(0.1, dist_to_goal * 0.5)  # Slow down as we approach
            omega = heading_error * 2.0  # Turn toward goal
            omega = np.clip(omega, -self.cfg.MAX_ANGULAR_VEL, self.cfg.MAX_ANGULAR_VEL)
            
            return v, omega
        
        if dist_to_goal < self.cfg.GOAL_TOLERANCE:
            return 0.0, 0.0

        dists = [distance(x, y, px, py) for px, py in zip(self.path_x, self.path_y)]
        closest_idx = int(np.argmin(dists))

        path_s = [0.0]
        for i in range(1, len(self.path_x)):
            dx = self.path_x[i] - self.path_x[i - 1]
            dy = self.path_y[i] - self.path_y[i - 1]
            path_s.append(path_s[-1] + math.hypot(dx, dy))

        s_closest = path_s[closest_idx]
        
        # ADAPTIVE LOOKAHEAD: Reduce when near goal
        if dist_to_goal < 1.0:
            adaptive_lookahead = max(self.cfg.MIN_LOOKAHEAD, 
                                    self.cfg.LOOKAHEAD_DISTANCE * (dist_to_goal / 1.0))
        else:
            adaptive_lookahead = max(self.cfg.MIN_LOOKAHEAD, self.cfg.LOOKAHEAD_DISTANCE)
        
        s_lookahead = s_closest + adaptive_lookahead

        if s_lookahead > path_s[-1]:
            lookahead_idx = len(self.path_x) - 1
        else:
            lookahead_idx = closest_idx
            for i in range(closest_idx, len(path_s)):
                if path_s[i] >= s_lookahead:
                    lookahead_idx = i
                    break

        lx = self.path_x[lookahead_idx]
        ly = self.path_y[lookahead_idx]

        alpha = math.atan2(ly - y, lx - x)
        ld = max(distance(x, y, lx, ly), self.cfg.MIN_TURNING_RADIUS)
        curvature = 2 * math.sin(wrap_to_pi(alpha - theta)) / ld

        # SLOW DOWN NEAR GOAL
        if dist_to_goal < 1.0:
            base_v = self.cfg.V_DESIRED * (0.3 + 0.7 * (dist_to_goal / 1.0))
        else:
            base_v = self.cfg.V_DESIRED
            
        if abs(curvature) > 1e-3:
            v_turn_limited = self.cfg.MAX_ANGULAR_VEL / abs(curvature)
            v = min(base_v, v_turn_limited)
        else:
            v = base_v
        v = max(0.05, v)

        omega = curvature * v
        omega = np.clip(omega, -self.cfg.MAX_ANGULAR_VEL, self.cfg.MAX_ANGULAR_VEL)
        return v, omega

    def step(self, x, y, theta, t_now):
        """
        Returns (v, omega, goal_reached, replanned, emergency_stop).
        NEW: Smart avoidance maneuver - reverse and turn when blocked.
        """

        # --- EMERGENCY COLLISION CHECK - Start avoidance maneuver ---
        collision_imminent, min_dist, closest_robot = \
            self.other_robots_tracker.check_collision_imminent(x, y)
        
        if collision_imminent and not self.is_avoiding and not self.is_reversing:
            # Check cooldown before starting new avoidance
            if (t_now - self.last_avoid_end_time) > self.AVOID_COOLDOWN:
                print(f"[AVOID] Robot too close ({min_dist:.2f}m)! Starting avoidance maneuver.")
                self.is_avoiding = True
                self.avoid_start_time = t_now
                self.avoid_maneuver_phase = 0  # Start with reverse
                # Don't return yet, let the avoidance logic below handle it

        # --- Handle active avoidance maneuver (NEW!) ---
        if self.is_avoiding:
            elapsed = t_now - self.avoid_start_time
            
            # Phase 0: Reverse
            if self.avoid_maneuver_phase == 0:
                if elapsed < self.avoid_reverse_duration:
                    print(f"[AVOID] Phase 1: Reversing... ({elapsed:.1f}s)")
                    return -0.20, 0.0, False, False, False  # Reverse at 0.2 m/s
                else:
                    # Done reversing, move to turn phase
                    self.avoid_maneuver_phase = 1
                    self.avoid_start_time = t_now  # Reset timer for turn phase
                    print("[AVOID] Phase 2: Turning to find alternate path...")
            
            # Phase 1: Turn to find clear direction
            if self.avoid_maneuver_phase == 1:
                elapsed = t_now - self.avoid_start_time
                if elapsed < self.avoid_turn_duration:
                    # Turn away from closest robot
                    if closest_robot:
                        # Calculate direction away from obstacle
                        to_obstacle_angle = math.atan2(closest_robot[1] - y, 
                                                       closest_robot[0] - x)
                        angle_diff = wrap_to_pi(to_obstacle_angle - theta)
                        # Turn away from obstacle
                        turn_direction = -1 if angle_diff > 0 else 1
                        omega_avoid = turn_direction * self.cfg.MAX_ANGULAR_VEL * 0.5
                    else:
                        # No closest robot info, just turn right
                        omega_avoid = -self.cfg.MAX_ANGULAR_VEL * 0.5
                    return 0.0, omega_avoid, False, False, False
                else:
                    # Done with maneuver, replan and continue
                    print("[AVOID] Maneuver complete, replanning path...")
                    self.is_avoiding = False
                    self.last_avoid_end_time = t_now
                    # Force replan from current position
                    ok = self.plan_path(x, y, theta)
                    self.last_progress_pos = (x, y)
                    self.last_progress_time = t_now
                    self.last_replan_time = t_now
                    # Continue to normal operation

        # --- Handle stuck reversing maneuver ---
        if self.is_reversing:
            elapsed = t_now - self.reverse_start_time
            if self.reverse_start_pos is not None:
                dist_rev = distance(x, y,
                                    self.reverse_start_pos[0],
                                    self.reverse_start_pos[1])
            else:
                dist_rev = 0.0

            if (elapsed >= self.reverse_duration) or (dist_rev >= self.reverse_distance_target):
                print(f"[CTRL] Finished reversing ({dist_rev:.2f} m) → replanning")
                self.is_reversing = False
                self.last_reverse_end_time = t_now
                ok = self.plan_path(x, y, theta)
                self.last_progress_pos = (x, y)
                self.last_progress_time = t_now
                self.last_replan_time = t_now
            else:
                v_reverse = -0.15
                omega_reverse = 0.0
                return v_reverse, omega_reverse, False, False, False

        # --- No goal? ---
        if self.goal_x is None:
            return 0.0, 0.0, False, False, False

        # Initialize progress tracking
        if self.last_progress_pos is None:
            self.last_progress_pos = (x, y)
            self.last_progress_time = t_now

        # --- Goal check ---
        dist_goal = distance(x, y, self.goal_x, self.goal_y)
        goal_reached = dist_goal < self.cfg.GOAL_TOLERANCE
        if goal_reached:
            return 0.0, 0.0, True, False, False

        # --- Stuck detection ---
        moved = distance(x, y, self.last_progress_pos[0], self.last_progress_pos[1])
        if moved > self.cfg.STUCK_DIST_THRESHOLD:
            self.last_progress_pos = (x, y)
            self.last_progress_time = t_now

        stuck = (t_now - self.last_progress_time) > self.cfg.STUCK_TIMEOUT

        replanned = False

        # --- Dynamic obstacle replanning (NEW!) ---
        if self.path_x and self.should_replan_for_obstacle(x, y, t_now):
            print("[CTRL] Other robot blocking path → replanning")
            ok = self.plan_path(x, y, theta)
            if ok:
                replanned = True
                self.last_replan_time = t_now
                self.last_progress_pos = (x, y)
                self.last_progress_time = t_now

        # Case A: no path yet → plan
        if not self.path_x:
            ok = self.plan_path(x, y, theta)
            if not ok:
                # FALLBACK: If planning completely fails, use direct path
                print("[CTRL] Using direct path (arena too crowded for A*)")
                num_points = 10
                self.path_x = [x + (self.goal_x - x) * i / num_points for i in range(num_points + 1)]
                self.path_y = [y + (self.goal_y - y) * i / num_points for i in range(num_points + 1)]
                ok = True
            replanned = ok
            self.last_progress_pos = (x, y)
            self.last_progress_time = t_now
            self.last_replan_time = t_now

        # Case B: stuck → reverse then replan (different from avoidance maneuver)
        elif stuck:
            if (t_now - self.last_reverse_end_time) > self.REVERSE_COOLDOWN:
                print("[CTRL] Stuck detected → starting reverse before replanning.")
                self.is_reversing = True
                self.reverse_start_time = t_now
                self.reverse_start_pos = (x, y)
                return -0.15, 0.0, False, False, False
            else:
                print("[CTRL] Stuck detected but in reverse cooldown → direct replan.")
                ok = self.plan_path(x, y, theta)
                if not ok:
                    print("[CTRL] Using direct path fallback")
                    num_points = 10
                    self.path_x = [x + (self.goal_x - x) * i / num_points for i in range(num_points + 1)]
                    self.path_y = [y + (self.goal_y - y) * i / num_points for i in range(num_points + 1)]
                replanned = True
                self.last_progress_pos = (x, y)
                self.last_progress_time = t_now
                self.last_replan_time = t_now

        # --- Normal pure pursuit tracking ---
        v, omega = self.pure_pursuit(x, y, theta)
        
        # Slow down if other robots are nearby (but not emergency close)
        other_positions = self.other_robots_tracker.get_other_robot_positions()
        if other_positions:
            min_dist_to_others = min(distance(x, y, ox, oy) 
                                    for ox, oy in other_positions)
            if min_dist_to_others < self.cfg.COLLISION_AVOIDANCE_DISTANCE:
                # Slow down proportionally
                slowdown_factor = min_dist_to_others / self.cfg.COLLISION_AVOIDANCE_DISTANCE
                slowdown_factor = max(0.2, slowdown_factor)  # At least 20% speed
                v *= slowdown_factor
                # Only print occasionally to avoid spam
                if int(t_now * 2) % 2 == 0:  # Every 0.5 seconds
                    print(f"[AVOID] Slowing to {slowdown_factor*100:.0f}% (robot {min_dist_to_others:.2f}m away)")
        
        return v, omega, False, replanned, False


# =============================================================================
# SIMULATED ROBOT (for testing)
# =============================================================================

class SimRobot:
    def __init__(self, x, y, theta):
        self.x = x
        self.y = y
        self.theta = theta
        self.traj_x = [x]
        self.traj_y = [y]

    def update(self, v, omega, dt):
        self.theta += omega * dt
        self.theta = wrap_to_pi(self.theta)
        self.x += v * math.cos(self.theta) * dt
        self.y += v * math.sin(self.theta) * dt
        self.traj_x.append(self.x)
        self.traj_y.append(self.y)

    def pose(self):
        return [self.x, self.y, self.theta]


# =============================================================================
# MAIN LOOP
# =============================================================================

def run_single_limo(simulation=False):
    cfg = Config()
    
    # COORDINATE SYSTEM CHECK
    print("=" * 70)
    print("COORDINATE SYSTEM CONFIGURATION")
    print("=" * 70)
    print(f"Arena bounds: X=[{cfg.ARENA_X_MIN}, {cfg.ARENA_X_MAX}], Y=[{cfg.ARENA_Y_MIN}, {cfg.ARENA_Y_MAX}]")
    print(f"Arena size: {cfg.ARENA_X_MAX - cfg.ARENA_X_MIN}m × {cfg.ARENA_Y_MAX - cfg.ARENA_Y_MIN}m")
    print(f"MoCap origin offset: ({cfg.MOCAP_ORIGIN_X}, {cfg.MOCAP_ORIGIN_Y})")
    print(f"MoCap Y-axis flip: {cfg.MOCAP_FLIP_Y}")
    print()
    print("Expected coordinate system:")
    print("  Origin: Center of red tape rectangle")
    print("  +X toward hallway windows, +Y toward street")
    print("  Example goals: (4.5, 2.5) = near hallway door")
    print("                 (-4.5, -2.5) = near RASTIC room door")
    print("=" * 70)
    print()
    
    # Create other robots tracker
    other_robots_tracker = OtherRobotsTracker(cfg)
    if not simulation:
        other_robots_tracker.connect()
        time.sleep(0.5)  # Let it connect
    
    controller = SingleRobotController(cfg, other_robots_tracker)

    # Networking / control interfaces
    tcp_socket = None
    mqtt_pose = None
    demo_mqtt = None
    local_demo = None

    if simulation:
        sim_robot = SimRobot(3.0, 2.25, 0.0)
        prev_pose = sim_robot.pose()
        local_demo = LocalDemoControl(cfg)
    else:
        # REAL ROBOT PATH
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp_socket.settimeout(2.0)
        limo_ip = cfg.LIMO_IP_PREFIX + cfg.LIMO_IP_LAST_3
        print("Connecting to LIMO at", limo_ip, "on port", cfg.LIMO_PORT)
        try:
            tcp_socket.connect((limo_ip, cfg.LIMO_PORT))
            print("✓ TCP connected.")
        except Exception as e:
            print("✗ TCP connection failed:", e)
            return

        mqtt_pose = MQTTDataHolder(cfg.LIMO_NUMBER, cfg.MQTT_BROKER)
        mqtt_pose.connect()

        demo_mqtt = DemoControlMQTT(cfg)
        demo_mqtt.connect()

        time.sleep(1.0)
        pose, valid = get_robot_pose_mqtt(mqtt_pose, cfg, None, 0.0)
        if not valid:
            print("No MoCap data, aborting.")
            return
        prev_pose = pose

    # Visualization
    plt.ion()
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.set_xlim(cfg.ARENA_X_MIN - 0.5, cfg.ARENA_X_MAX + 0.5)
    ax.set_ylim(cfg.ARENA_Y_MIN - 0.5, cfg.ARENA_Y_MAX + 0.5)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.set_xlabel("X [m]")
    ax.set_ylabel("Y [m]")
    ax.set_title("Multi-Robot Navigation with Collision Avoidance")
    
    arena = Rectangle((cfg.ARENA_X_MIN, cfg.ARENA_Y_MIN),
                      cfg.ARENA_X_MAX - cfg.ARENA_X_MIN,
                      cfg.ARENA_Y_MAX - cfg.ARENA_Y_MIN,
                      fill=False, edgecolor='black', linewidth=2)
    ax.add_patch(arena)

    path_line, = ax.plot([], [], 'b--', linewidth=1.5, label="Planned path", alpha=0.7)
    traj_line, = ax.plot([], [], 'r-', linewidth=2, label="My trajectory")
    goal_marker = Circle((0, 0), cfg.GOAL_TOLERANCE, color='green', alpha=0.4)
    ax.add_patch(goal_marker)
    
    robot_circle = Circle((prev_pose[0], prev_pose[1]), cfg.ROBOT_VISUAL_RADIUS,
                          color='cyan', zorder=3, label='Me')
    ax.add_patch(robot_circle)
    
    heading_arrow = ax.arrow(prev_pose[0], prev_pose[1], 0.3, 0,
                             head_width=0.08, head_length=0.08,
                             fc='black', ec='black')
    
    # Visualization for other robots (NEW!)
    other_robot_circles = []
    
    ax.legend(loc='upper right')
    plt.tight_layout()

    start_time = time.time()

    try:
        while True:
            loop_start = time.time()
            t = loop_start - start_time
            dt = cfg.dt

            # Get pose
            if simulation:
                pose = sim_robot.pose()
            else:
                pose, valid = get_robot_pose_mqtt(mqtt_pose, cfg, prev_pose, dt)
                if not valid:
                    print("No MoCap pose, commanding stop.")
                    v_cmd, omega_cmd = 0.0, 0.0
                    if tcp_socket:
                        try:
                            tcp_socket.sendall(f"{v_cmd:.2f},{omega_cmd:.2f}".encode('utf-8'))
                        except Exception:
                            pass
                    time.sleep(cfg.dt)
                    continue

            x, y, theta = pose

            # Safety: arena bounds check
            if (x < cfg.ARENA_X_MIN - 0.1 or x > cfg.ARENA_X_MAX + 0.1 or
                    y < cfg.ARENA_Y_MIN - 0.1 or y > cfg.ARENA_Y_MAX + 0.1):
                print("[SAFETY] Robot outside arena bounds! Forcing stop.")
                v_cmd, omega_cmd = 0.0, 0.0
                if tcp_socket:
                    try:
                        tcp_socket.sendall(f"{v_cmd:.2f},{omega_cmd:.2f}".encode('utf-8'))
                    except Exception:
                        pass
                break

            # Get run_state and goal
            if simulation:
                run_state = local_demo.get_run_state()
                goal = local_demo.get_goal()
            else:
                run_state = demo_mqtt.get_run_state()
                goal = demo_mqtt.get_goal()

            # Update controller goal
            if goal is not None:
                gx, gy = goal
                if controller.goal_x is None or (gx != controller.goal_x or gy != controller.goal_y):
                    controller.set_goal(gx, gy)
                    controller.plan_path(x, y)

            # Default commands
            v_cmd, omega_cmd = 0.0, 0.0
            emergency_stop = False

            # State machine
            if run_state == "HALT":
                v_cmd, omega_cmd = 0.0, 0.0
                print("[STATE] HALT → Stopping and exiting.")
                if tcp_socket:
                    try:
                        tcp_socket.sendall(f"{v_cmd:.2f},{omega_cmd:.2f}".encode('utf-8'))
                    except Exception:
                        pass
                break

            elif run_state == "STOP":
                v_cmd, omega_cmd = 0.0, 0.0

            elif run_state == "WAIT":
                v_cmd, omega_cmd = 0.0, 0.0

            elif run_state == "GO":
                v_cmd, omega_cmd, goal_reached, replanned, emergency_stop = \
                    controller.step(x, y, theta, t)
                if goal_reached:
                    print("✓ Goal reached. Holding position.")
                    v_cmd, omega_cmd = 0.0, 0.0

            else:
                v_cmd, omega_cmd = 0.0, 0.0

            # Apply command
            if simulation:
                sim_robot.update(v_cmd, omega_cmd, dt)
            else:
                try:
                    tcp_socket.sendall(f"{v_cmd:.2f},{omega_cmd:.2f}".encode('utf-8'))
                except Exception:
                    print("TCP send failed.")
                    break

            # Update plot
            if simulation:
                pose_plot = sim_robot.pose()
                traj_x = sim_robot.traj_x
                traj_y = sim_robot.traj_y
            else:
                pose_plot = pose
                if 'traj_x' not in locals():
                    traj_x, traj_y = [x], [y]
                else:
                    traj_x.append(x)
                    traj_y.append(y)

            robot_circle.center = (pose_plot[0], pose_plot[1])

            if controller.path_x:
                path_line.set_data(controller.path_x, controller.path_y)

            if controller.goal_x is not None:
                goal_marker.center = (controller.goal_x, controller.goal_y)

            traj_line.set_data(traj_x, traj_y)

            if heading_arrow in ax.patches:
                heading_arrow.remove()
            dx_vec = 0.3 * math.cos(pose_plot[2])
            dy_vec = 0.3 * math.sin(pose_plot[2])
            heading_arrow = ax.arrow(pose_plot[0], pose_plot[1], dx_vec, dy_vec,
                                     head_width=0.08, head_length=0.08,
                                     fc='black', ec='black', zorder=4)

            # Visualize other robots (NEW!)
            for circle in other_robot_circles:
                circle.remove()
            other_robot_circles.clear()
            
            if not simulation:
                other_positions = other_robots_tracker.get_other_robot_positions()
                for ox, oy in other_positions:
                    other_circle = Circle((ox, oy), cfg.ROBOT_VISUAL_RADIUS,
                                         color='orange', alpha=0.6, zorder=2)
                    ax.add_patch(other_circle)
                    other_robot_circles.append(other_circle)

            status_str = f"State: {run_state}"
            if emergency_stop:
                status_str += " [EMERGENCY STOP!]"
            status_str += f" | t = {t:.1f}s | v = {v_cmd:.2f}, ω = {omega_cmd:.2f}"
            
            if not simulation:
                other_count = len(other_robots_tracker.get_other_robot_positions())
                status_str += f" | Other robots: {other_count}"
            
            ax.set_title(status_str)
            plt.pause(0.001)

            prev_pose = pose
            sleep_time = cfg.dt - (time.time() - loop_start)
            if sleep_time > 0:
                time.sleep(sleep_time)

    except KeyboardInterrupt:
        print("\nKeyboardInterrupt → stopping...")

    finally:
        if tcp_socket:
            try:
                tcp_socket.sendall(b"0.00,0.00")
                tcp_socket.close()
                print("✓ Closed TCP connection.")
            except Exception:
                print("⚠️ Error closing TCP socket.")
        if mqtt_pose:
            mqtt_pose.stop()
        if demo_mqtt:
            demo_mqtt.stop()
        if local_demo:
            local_demo.stop()
        if other_robots_tracker:
            other_robots_tracker.stop()
        plt.ioff()
        plt.show()


# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    use_sim = True
    try:
        ans = input("Run in simulation? (y/n) [y]: ").strip().lower()
        use_sim = (ans != 'n')
    except Exception:
        pass

    run_single_limo(simulation=use_sim)
