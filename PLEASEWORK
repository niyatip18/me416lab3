#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LIMO – Lab 3 Phase 2 Real-Time Controller (Single Physical Robot)

- Subscribes to:
    rb/#               -> MoCap for ALL robots
    cmd/limoXXX        -> runState: WAIT / GO / STOP / HALT (for THIS robot)
    goal/limoXXX       -> {"goal":[x,y]} (only honored in WAIT, for THIS robot)

- Uses:
    * A* path planning on a bounded arena
    * Pure Pursuit controller
    * Lab3 Phase2-style dynamic obstacle avoidance:
        - Other robots treated as dynamic obstacles
        - Predict their future positions using velocity
        - Inflate keep-out regions
        - Scale speed based on nearest robot distance

- Sends velocity commands over TCP to the physical LIMO.

IMPORTANT:
    Set Config.LIMO_NUMBER and LIMO_IP_LAST_3 before running.
"""

import math
import time
import json
import socket
import threading
from collections import defaultdict

import numpy as np
import paho.mqtt.client as mqtt


# =============================================================================
# CONFIGURATION
# =============================================================================

class Config:
    """Configuration parameters for real robot + avoidance"""

    # --- IDENTIFIERS / NETWORK ---
    LIMO_NUMBER = "777"          # <-- change to your limo ID
    LIMO_IP_LAST_3 = "101"       # <-- last 3 digits of robot IP
    LIMO_IP_PREFIX = "192.168.1."
    LIMO_PORT = 12345
    MQTT_BROKER = "rasticvm.lan"

    # --- ARENA BOUNDS (meters) ---
    ARENA_X_MIN = 0.0
    ARENA_X_MAX = 6.0
    ARENA_Y_MIN = 0.0
    ARENA_Y_MAX = 4.5

    # --- MoCap origin transform (same as your Lab 2 code) ---
    MOCAP_ORIGIN_X = -4.5
    MOCAP_ORIGIN_Y = 2.7

    # --- Robot geometry / motion ---
    ROBOT_RADIUS = 0.15
    GOAL_TOLERANCE = 0.18

    V_DESIRED = 0.25              # nominal forward speed [m/s]
    MAX_ANGULAR_VEL = math.radians(60)
    MIN_TURNING_RADIUS = 0.25

    # --- A* planning ---
    GRID_SIZE = 0.25

    # --- Multi-robot avoidance (Phase 2 style) ---
    BASE_SAFETY_RADIUS = 0.4
    VELOCITY_SCALE_FACTOR = 0.25
    PREDICTION_HORIZON = 1.0
    REPLAN_INTERVAL = 0.7

    # --- Control loop timing ---
    CONTROL_RATE = 20.0           # [Hz]
    dt = 1.0 / CONTROL_RATE
    PRINT_PERIOD = 1.0            # [s]


# =============================================================================
# UTILS
# =============================================================================

def wrap_to_pi(angle):
    return (angle + math.pi) % (2 * math.pi) - math.pi


def distance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)


def quaternion_to_yaw(qx, qy, qz, qw):
    # Same convention as in your previous code (negated later)
    return math.atan2(
        2.0 * (qw * qz + qx * qy),
        1.0 - 2.0 * (qy * qy + qz * qz)
    )


def mocap_to_arena(pos_raw, cfg: Config):
    """
    OptiTrack pos = [x, y, z]
    Use same transform as your Lab 2 script:
        X = x - origin_x
        Y = -(z - origin_y)
    """
    x_raw, _, z_raw = pos_raw
    X = x_raw - cfg.MOCAP_ORIGIN_X
    Y = -(z_raw - cfg.MOCAP_ORIGIN_Y)
    return X, Y


# =============================================================================
# A* PLANNER (Phase 2 style: bounded continuous space)
# =============================================================================

class AStarPlanner:
    """Grid-based A* planner over rectangular arena with obstacles."""

    def __init__(self, obstacles, resolution, rr, bounds):
        """
        obstacles: list of (x, y) points representing obstacles
        resolution: grid resolution [m]
        rr: robot radius [m]
        bounds: (min_x, max_x, min_y, max_y)
        """
        self.resolution = resolution
        self.rr = rr
        self.min_x, self.max_x, self.min_y, self.max_y = bounds
        self.motion = self.get_motion_model()

        self.x_width = round((self.max_x - self.min_x) / self.resolution)
        self.y_width = round((self.max_y - self.min_y) / self.resolution)
        self.obstacle_map = self.calc_obstacle_map(obstacles)

    class Node:
        def __init__(self, x, y, cost, parent_index):
            self.x = x
            self.y = y
            self.cost = cost
            self.parent_index = parent_index

    def planning(self, sx, sy, gx, gy):
        """Run A* from (sx, sy) to (gx, gy) in world coords."""
        start_node = self.Node(
            self.calc_xy_index(sx, self.min_x),
            self.calc_xy_index(sy, self.min_y),
            0.0, -1
        )
        goal_node = self.Node(
            self.calc_xy_index(gx, self.min_x),
            self.calc_xy_index(gy, self.min_y),
            0.0, -1
        )

        open_set, closed_set = dict(), dict()
        open_set[self.calc_grid_index(start_node)] = start_node

        while True:
            if len(open_set) == 0:
                return None, None

            # Choose node with min f = g + h
            c_id = min(
                open_set,
                key=lambda o: open_set[o].cost +
                self.calc_heuristic(goal_node, open_set[o])
            )
            current = open_set[c_id]

            # Reached goal
            if current.x == goal_node.x and current.y == goal_node.y:
                goal_node.parent_index = current.parent_index
                goal_node.cost = current.cost
                return self.calc_final_path(goal_node, closed_set)

            del open_set[c_id]
            closed_set[c_id] = current

            # Expand
            for i, _ in enumerate(self.motion):
                node = self.Node(
                    current.x + self.motion[i][0],
                    current.y + self.motion[i][1],
                    current.cost + self.motion[i][2],
                    c_id
                )
                n_id = self.calc_grid_index(node)

                if not self.verify_node(node):
                    continue
                if n_id in closed_set:
                    continue
                if n_id not in open_set or open_set[n_id].cost > node.cost:
                    open_set[n_id] = node

    def calc_final_path(self, goal_node, closed_set):
        rx = [self.calc_grid_position(goal_node.x, self.min_x)]
        ry = [self.calc_grid_position(goal_node.y, self.min_y)]
        parent_index = goal_node.parent_index
        while parent_index != -1:
            n = closed_set[parent_index]
            rx.append(self.calc_grid_position(n.x, self.min_x))
            ry.append(self.calc_grid_position(n.y, self.min_y))
            parent_index = n.parent_index
        return rx, ry

    @staticmethod
    def calc_heuristic(n1, n2):
        return math.hypot(n1.x - n2.x, n1.y - n2.y)

    def calc_grid_position(self, index, min_position):
        return index * self.resolution + min_position

    def calc_xy_index(self, position, min_pos):
        return round((position - min_pos) / self.resolution)

    def calc_grid_index(self, node):
        return (node.y - 0) * self.x_width + (node.x - 0)

    def verify_node(self, node):
        px = self.calc_grid_position(node.x, self.min_x)
        py = self.calc_grid_position(node.y, self.min_y)

        if px < self.min_x or py < self.min_y:
            return False
        if px >= self.max_x or py >= self.max_y:
            return False

        if self.obstacle_map[node.x][node.y]:
            return False

        return True

    def calc_obstacle_map(self, obstacles):
        obstacle_map = [[False for _ in range(self.y_width)]
                        for _ in range(self.x_width)]

        for ix in range(self.x_width):
            x = self.calc_grid_position(ix, self.min_x)
            for iy in range(self.y_width):
                y = self.calc_grid_position(iy, self.min_y)

                # Inflate arena walls a bit as obstacles
                margin = 0.3
                if x < self.min_x + margin or x > self.max_x - margin:
                    obstacle_map[ix][iy] = True
                    continue
                if y < self.min_y + margin or y > self.max_y - margin:
                    obstacle_map[ix][iy] = True
                    continue

                # Check dynamic obstacles
                for ox, oy in obstacles:
                    d = math.hypot(ox - x, oy - y)
                    if d <= self.rr:
                        obstacle_map[ix][iy] = True
                        break

        return obstacle_map

    @staticmethod
    def get_motion_model():
        return [
            [1, 0, 1],
            [0, 1, 1],
            [-1, 0, 1],
            [0, -1, 1],
            [-1, -1, math.sqrt(2)],
            [-1, 1, math.sqrt(2)],
            [1, -1, math.sqrt(2)],
            [1, 1, math.sqrt(2)]
        ]


# =============================================================================
# MQTT / MOCAP INTERFACE
# =============================================================================

class MultiRobotMQTT:
    """
    Subscribes to:

        rb/#              -> MoCap for all robots
        cmd/limoXXX       -> runState for THIS robot
        goal/limoXXX      -> goal for THIS robot (honored only in WAIT)

    Maintains:
        robots[id] = {
            "pos_raw": [x,y,z],
            "rot_raw": [qx,qy,qz,qw],
            "x": X_arena,
            "y": Y_arena,
            "theta": yaw,
            "vx": vx,
            "vy": vy,
            "last_update": t
        }

        run_state : "WAIT" / "GO" / "STOP" / "HALT"
        goal      : [x, y] in arena coords (None if unset)
        goal_version : increments when goal is changed
    """

    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.self_id = cfg.LIMO_NUMBER

        self.robots = defaultdict(lambda: {
            "pos_raw": None,
            "rot_raw": None,
            "x": None, "y": None, "theta": None,
            "vx": 0.0, "vy": 0.0,
            "last_update": None
        })

        self.run_state = "WAIT"
        self.goal = None
        self.goal_version = 0

        self.lock = threading.Lock()

        # Topics
        self.topic_mocap = "rb/#"
        self.topic_cmd = f"cmd/limo{self.self_id}"
        self.topic_goal = f"goal/limo{self.self_id}"

        # MQTT client
        self.client = mqtt.Client()
        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message

    def _on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print("✓ MQTT connected.")
            self.client.subscribe(self.topic_mocap)
            self.client.subscribe(self.topic_cmd)
            self.client.subscribe(self.topic_goal)
            print(f"  Subscribed to: {self.topic_mocap}, {self.topic_cmd}, {self.topic_goal}")
        else:
            print("✗ MQTT connection failed:", rc)

    def _on_message(self, client, userdata, msg):
        topic = msg.topic
        payload = msg.payload.decode("utf-8").strip()

        # 1) MoCap: rb/limoXYZ
        if topic.startswith("rb/limo"):
            robot_id = topic.split("rb/limo")[-1]  # e.g. "777"
            try:
                data = json.loads(payload)
            except json.JSONDecodeError:
                return

            with self.lock:
                entry = self.robots[robot_id]
                prev_x, prev_y = entry["x"], entry["y"]
                prev_t = entry["last_update"]

                if "pos" in data:
                    entry["pos_raw"] = data["pos"]
                    x, y = mocap_to_arena(data["pos"], self.cfg)
                    entry["x"], entry["y"] = x, y

                if "rot" in data:
                    entry["rot_raw"] = data["rot"]
                    qx, qy, qz, qw = data["rot"]
                    # same convention as your Lab2: negative yaw
                    yaw = -quaternion_to_yaw(qx, qy, qz, qw)
                    entry["theta"] = wrap_to_pi(yaw)

                t_now = time.time()
                if prev_x is not None and prev_y is not None and prev_t is not None:
                    dt = t_now - prev_t
                    if dt > 1e-3:
                        entry["vx"] = (entry["x"] - prev_x) / dt
                        entry["vy"] = (entry["y"] - prev_y) / dt

                entry["last_update"] = t_now

        # 2) Command: cmd/limoXXX
        elif topic == self.topic_cmd:
            with self.lock:
                if payload in ("WAIT", "GO", "STOP", "HALT"):
                    self.run_state = payload
                    print(f"[CMD] runState → {self.run_state}")
                else:
                    print(f"[CMD] Unknown payload: {payload}")

        # 3) Goal: goal/limoXXX
        elif topic == self.topic_goal:
            with self.lock:
                if self.run_state != "WAIT":
                    print(f"[GOAL] Ignoring goal (runState={self.run_state})")
                    return

            try:
                data = json.loads(payload)
                if "goal" in data and len(data["goal"]) == 2:
                    gx = float(data["goal"][0])
                    gy = float(data["goal"][1])
                    with self.lock:
                        self.goal = [gx, gy]
                        self.goal_version += 1
                    print(f"[GOAL] New goal set: ({gx:.2f}, {gy:.2f})")
                else:
                    print("[GOAL] Malformed payload:", payload)
            except Exception as e:
                print("[GOAL] Error decoding goal:", e, "payload:", payload)

    # ---- API ----

    def connect(self):
        self.client.connect(self.cfg.MQTT_BROKER, 1883, 60)
        self.client.loop_start()

    def stop(self):
        self.client.loop_stop()
        self.client.disconnect()

    def get_self_state(self):
        with self.lock:
            entry = self.robots[self.self_id].copy()
            run_state = self.run_state
            goal = None if self.goal is None else self.goal[:]
            goal_version = self.goal_version

        return entry, run_state, goal, goal_version

    def get_other_robots(self):
        robots = []
        with self.lock:
            for rid, entry in self.robots.items():
                if rid == self.self_id:
                    continue
                if entry["x"] is None or entry["y"] is None:
                    continue
                robots.append((rid, entry.copy()))
        return robots


# =============================================================================
# PATH REPRESENTATION
# =============================================================================

class Path:
    def __init__(self, x_list, y_list):
        self.x = np.array(x_list)
        self.y = np.array(y_list)
        self.s = np.zeros(len(self.x))
        for i in range(1, len(self.x)):
            dx = self.x[i] - self.x[i - 1]
            dy = self.y[i] - self.y[i - 1]
            self.s[i] = self.s[i - 1] + math.hypot(dx, dy)


def find_lookahead_point(robot_x, robot_y, path: Path, lookahead_dist):
    distances = np.sqrt((path.x - robot_x) ** 2 + (path.y - robot_y) ** 2)
    closest_idx = int(np.argmin(distances))
    s_lookahead = path.s[closest_idx] + lookahead_dist

    if s_lookahead > path.s[-1]:
        lookahead_idx = len(path.x) - 1
    else:
        idxs = np.where(path.s >= s_lookahead)[0]
        lookahead_idx = int(idxs[0]) if len(idxs) > 0 else len(path.x) - 1

    return (
        path.x[lookahead_idx],
        path.y[lookahead_idx],
        closest_idx,
        distances[closest_idx]
    )


# =============================================================================
# PHASE 2–STYLE AVOIDANCE HELPERS
# =============================================================================

def build_dynamic_obstacles(self_state, other_robots, cfg: Config):
    """
    From Phase 2:
    - Predict other robots' positions forward in time
    - Inflate radius based on speed
    - Return a list of (ox, oy) sample points around them
    """
    obstacles = []

    for rid, entry in other_robots:
        x = entry["x"]
        y = entry["y"]
        vx = entry["vx"]
        vy = entry["vy"]

        speed = math.hypot(vx, vy)
        pred_x = x + vx * cfg.PREDICTION_HORIZON
        pred_y = y + vy * cfg.PREDICTION_HORIZON

        radius = cfg.BASE_SAFETY_RADIUS + speed * cfg.VELOCITY_SCALE_FACTOR

        # Sample 8 points around predicted position
        for k in range(8):
            angle = 2 * math.pi * k / 8.0
            ox = pred_x + radius * math.cos(angle)
            oy = pred_y + radius * math.sin(angle)
            obstacles.append((ox, oy))

    return obstacles


def compute_velocity_scale(self_state, other_robots, cfg: Config):
    """
    Same concept as Robot.check_nearby_robots from Phase 2:
    - Find nearest robot
    - Scale speed between ~0.05 and 1.0 accordingly
    """
    sx, sy = self_state["x"], self_state["y"]
    if sx is None or sy is None:
        return 0.0

    min_dist = float("inf")
    for rid, entry in other_robots:
        x, y = entry["x"], entry["y"]
        if x is None or y is None:
            continue
        d = distance(sx, sy, x, y)
        min_dist = min(min_dist, d)

    if min_dist == float("inf"):
        return 1.0  # no other robots

    # Default full speed
    velocity_scale = 1.0

    # Critical zone
    critical_distance = (cfg.ROBOT_RADIUS * 2.0) + 0.15
    if min_dist < critical_distance:
        velocity_scale = 0.05
    else:
        collision_zone = 0.8
        if min_dist < collision_zone:
            velocity_scale = (min_dist - critical_distance) / (collision_zone - critical_distance)
            velocity_scale = max(0.15, velocity_scale ** 2)

    return max(0.05, min(1.0, velocity_scale))


# =============================================================================
# MAIN CONTROL LOOP
# =============================================================================

def main():
    cfg = Config()

    # --- TCP SETUP ---
    limo_ip = cfg.LIMO_IP_PREFIX + cfg.LIMO_IP_LAST_3
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(2.0)
    try:
        sock.connect((limo_ip, cfg.LIMO_PORT))
        print(f"✓ TCP connected to LIMO at {limo_ip}:{cfg.LIMO_PORT}")
    except Exception as e:
        print("✗ TCP connection failed:", e)
        return

    # --- MQTT SETUP ---
    mqtt_iface = MultiRobotMQTT(cfg)
    mqtt_iface.connect()
    time.sleep(1.0)

    path = None
    last_replan_time = 0.0
    last_goal_version = -1
    last_print_time = 0.0

    print("\n=== LIMO Lab 3 Phase 2 Real-Time Controller ===")
    print(f"Robot ID: limo{cfg.LIMO_NUMBER}")
    print("Waiting for MoCap + goal + GO command...\n")

    try:
        while True:
            t_now = time.time()

            self_state, run_state, goal, goal_version = mqtt_iface.get_self_state()
            other_robots = mqtt_iface.get_other_robots()

            x = self_state["x"]
            y = self_state["y"]
            theta = self_state["theta"]

            # Require valid pose to do anything
            if x is None or y is None or theta is None:
                # still ensure STOP behavior
                try:
                    sock.sendall(b"0.00,0.00")
                except Exception:
                    pass
                time.sleep(cfg.dt)
                continue

            # Handle HALT: stop and exit
            if run_state == "HALT":
                try:
                    sock.sendall(b"0.00,0.00")
                except Exception:
                    pass
                print("[STATE] HALT received – exiting.")
                break

            # If STOP or WAIT or no goal → send zero velocities
            if run_state in ("STOP", "WAIT") or goal is None:
                try:
                    sock.sendall(b"0.00,0.00")
                except Exception:
                    pass
                # Reset path if goal version changed while waiting
                if goal_version != last_goal_version:
                    path = None
                    last_goal_version = goal_version
                time.sleep(cfg.dt)
                continue

            # From here on: run_state must be GO and we have a goal
            gx, gy = goal

            # Replan if:
            #   - no path yet
            #   - new goal received
            #   - replanning interval elapsed
            need_replan = False
            if path is None:
                need_replan = True
            elif goal_version != last_goal_version:
                need_replan = True
            elif (t_now - last_replan_time) > cfg.REPLAN_INTERVAL:
                need_replan = True

            if need_replan:
                # Build dynamic obstacles
                dyn_obs = build_dynamic_obstacles(self_state, other_robots, cfg)
                bounds = (cfg.ARENA_X_MIN, cfg.ARENA_X_MAX,
                          cfg.ARENA_Y_MIN, cfg.ARENA_Y_MAX)

                try:
                    planner = AStarPlanner(dyn_obs, cfg.GRID_SIZE, cfg.ROBOT_RADIUS, bounds)
                    rx, ry = planner.planning(x, y, gx, gy)
                except Exception as e:
                    print("A* planning error:", e)
                    rx, ry = None, None

                if rx is None or ry is None:
                    # If planning failed, just stop for now
                    try:
                        sock.sendall(b"0.00,0.00")
                    except Exception:
                        pass
                    time.sleep(cfg.dt)
                    continue

                # Reverse path to start from current pose
                path = Path(rx[::-1], ry[::-1])
                last_replan_time = t_now
                last_goal_version = goal_version
                print(f"[PLAN] New path with {len(path.x)} waypoints to goal ({gx:.2f},{gy:.2f})")

            # Check if we've reached the goal
            if path is not None:
                dist_to_goal = distance(x, y, path.x[-1], path.y[-1])
                if dist_to_goal < cfg.GOAL_TOLERANCE:
                    try:
                        sock.sendall(b"0.00,0.00")
                    except Exception:
                        pass
                    print("✓ Goal reached within tolerance.")
                    # Wait for next goal (must come in WAIT)
                    path = None
                    time.sleep(cfg.dt)
                    continue

            # --- PURE PURSUIT WITH VELOCITY SCALING ---

            lookahead_dist = max(cfg.MIN_TURNING_RADIUS, cfg.V_DESIRED * cfg.dt * 5.0)
            lx, ly, _, _ = find_lookahead_point(x, y, path, lookahead_dist)

            alpha = math.atan2(ly - y, lx - x)
            ld = max(distance(x, y, lx, ly), cfg.MIN_TURNING_RADIUS)
            curvature = 2.0 * math.sin(wrap_to_pi(alpha - theta)) / ld

            # Phase 2: scale velocity based on proximity to other robots
            vel_scale = compute_velocity_scale(self_state, other_robots, cfg)
            base_v = cfg.V_DESIRED * vel_scale

            if abs(curvature) > 1e-3:
                v_turn_limit = cfg.MAX_ANGULAR_VEL / abs(curvature)
                v_cmd = min(base_v, v_turn_limit)
            else:
                v_cmd = base_v

            v_cmd = max(0.05, v_cmd)  # don't completely stall
            omega_cmd = curvature * v_cmd
            omega_cmd = max(-cfg.MAX_ANGULAR_VEL, min(cfg.MAX_ANGULAR_VEL, omega_cmd))

            # If for some reason run_state flipped out of GO in between
            if run_state != "GO":
                v_cmd, omega_cmd = 0.0, 0.0

            # --- SEND COMMANDS ---
            try:
                msg = f"{v_cmd:.3f},{omega_cmd:.3f}".encode("utf-8")
                sock.sendall(msg)
            except Exception as e:
                print("TCP send error:", e)
                break

            # --- DIAGNOSTIC PRINT ---
            if (t_now - last_print_time) > cfg.PRINT_PERIOD:
                last_print_time = t_now
                print(
                    f"[STATE={run_state}] "
                    f"pose=({x:.2f},{y:.2f},{math.degrees(theta):.1f}°) "
                    f"goal=({gx:.2f},{gy:.2f}) "
                    f"v={v_cmd:.2f} ω={math.degrees(omega_cmd):.1f}°/s "
                    f"others={len(other_robots)}"
                )

            time.sleep(cfg.dt)

    except KeyboardInterrupt:
        print("\nKeyboardInterrupt – stopping.")

    finally:
        try:
            sock.sendall(b"0.00,0.00")
        except Exception:
            pass
        sock.close()
        mqtt_iface.stop()
        print("Clean shutdown complete.")


if __name__ == "__main__":
    main()
